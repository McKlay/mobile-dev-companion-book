{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Table of Contents","text":""},{"location":"#mobile-dev-builders-companion-book","title":"Mobile Dev Builder\u2019s Companion Book","text":""},{"location":"#from-react-native-to-expo-eas-a-guide-to-building-and-deploying-mobile-apps","title":"From React Native to Expo &amp; EAS \u2014 a guide to building and deploying mobile apps","text":""},{"location":"#contents","title":"Contents","text":""},{"location":"#preface","title":"\ud83d\udcd6 Preface","text":"<ul> <li> <p>Why This Book Exists</p> </li> <li> <p>Who Should Read This</p> </li> <li> <p>From Web Comfort to Mobile Reality</p> </li> <li> <p>What You\u2019ll Learn (and What You Won\u2019t)</p> </li> <li> <p>How to Read This Book</p> </li> </ul>"},{"location":"#part-i-foundations-of-cross-platform-mobile-development","title":"Part I \u2013 Foundations of Cross-Platform Mobile Development","text":"<p>Chapter 1: Why Mobile Feels Different from Web \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.1 Web vs. mobile mindset shift \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.2 React Native as the bridge between JavaScript and native UI  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01.3 Understanding Expo\u2019s role</p> <p>Chapter 2: The Expo Ecosystem \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.1 Expo SDK and its prebuilt modules \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.2 Metro bundler explained  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02.3 Expo Go vs Dev Client vs Production</p>"},{"location":"#part-ii-getting-started-with-your-first-project","title":"Part II \u2013 Getting Started with Your First Project","text":"<p>Chapter 3: Scaffolding a React Native App \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.1 Using <code>create-expo-app</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.2 Project structure explained  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03.3 Adding Tailwind with NativeWind</p> <p>Chapter 4: Running Your App on Web and Device \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.1 Fast Refresh &amp; Live Reload basics \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.2 Running with Expo Go on physical devices  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a04.3 When and why to switch to Dev Client</p>"},{"location":"#part-iii-surviving-dependency-hell","title":"Part III \u2013 Surviving Dependency Hell","text":"<p>Chapter 5: Library Compatibility Issues \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.1 Common problem packages (<code>react-native-reanimated</code>, <code>gesture-handler</code>) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.2 Using <code>expo-doctor</code> and <code>expo install</code>  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a05.3 How to interpret red Metro errors</p> <p>Chapter 6: Babel, Metro, and You \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.1 What Babel does in React Native projects \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.2 Metro bundler workflow (port 8081)  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a06.3 Hot reload vs full reload</p>"},{"location":"#part-iv-building-natively-with-eas","title":"Part IV \u2013 Building Natively with EAS","text":"<p>Chapter 7: Introduction to EAS (Expo Application Services) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.1 Why Expo Go is not enough \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.2 Installing and configuring EAS CLI  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a07.3 Understanding <code>eas.json</code> build profiles</p> <p>Chapter 8: Your First Native Build \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.1 Running <code>eas build -p android --profile development</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.2 Installing and testing the Dev Client APK  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a08.3 Differences between dev, preview, and production builds</p> <p>Chapter 9: Connecting Dev Client to Metro \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.1 Running <code>expo start --dev-client</code> \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.2 Using tunnels, hotspots, and deep links  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a09.3 USB fallback with <code>adb reverse</code></p>"},{"location":"#part-v-practical-lessons-and-next-steps","title":"Part V \u2013 Practical Lessons and Next Steps","text":"<p>Chapter 10: Tips from the Trenches \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.1 Avoiding common Expo pitfalls \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.2 Best practices for project hygiene  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010.3 Debugging strategies that actually work</p> <p>Chapter 11: Where to Go Next \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.1 Adding navigation and advanced UI (React Navigation, NativeWind) \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.2 Camera, file upload, and native APIs  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011.3 Preparing for Play Store and App Store deployment</p>"},{"location":"#technical-appendices-cheat-sheets-guides","title":"Technical Appendices (Cheat Sheets &amp; Guides)","text":"<p>A. CLI Commands Reference (Expo, EAS, adb) B. Comparison: Expo vs CRA/Vite (for web devs crossing into mobile) C. Troubleshooting Flowchart (Metro, builds, dependencies) D. Starter Project Template (Expo + NativeWind)  </p>"},{"location":"PartIII_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part III: Surviving Dependency Hell","text":""},{"location":"PartIII_overview/#part-iii-surviving-dependency-hell","title":"\ud83d\udfe2 Part III: Surviving Dependency Hell","text":"<p>Every mobile developer eventually encounters the infamous \"dependency hell.\" While React Native and Expo smooth many rough edges, the moment you introduce third-party libraries, mismatched versions, or native code, things can quickly spiral into frustration. This part of the book equips you with strategies, tools, and mental models to not just survive but navigate dependency issues with confidence.</p>"},{"location":"PartIII_overview/#chapter-5-library-compatibility-issues","title":"Chapter 5: Library Compatibility Issues","text":"<p>This chapter examines the most common troublemakers in the React Native ecosystem\u2014packages like <code>react-native-reanimated</code> and <code>react-native-gesture-handler</code>. You\u2019ll learn why these packages are often problematic, how to resolve version mismatches, and how to use Expo\u2019s recommended tools like <code>expo install</code> and <code>expo-doctor</code> to stay aligned with compatible versions.</p> <p>Key points covered:</p> <ul> <li>Identifying common problem libraries (<code>react-native-reanimated</code>, <code>gesture-handler</code>).  </li> <li>Using <code>expo install</code> to ensure version alignment.  </li> <li>Running <code>expo-doctor</code> to catch mismatches early.  </li> </ul>"},{"location":"PartIII_overview/#chapter-6-babel-metro-and-you","title":"Chapter 6: Babel, Metro, and You","text":"<p>When errors appear in blazing red screens, it\u2019s often unclear whether the issue comes from your code, Metro, or Babel. This chapter breaks down how Babel transforms your JavaScript, how Metro bundles your project, and how to interpret errors. You\u2019ll also explore the nuances of hot reload vs. full reload, so you know when to restart and when to debug incrementally.</p> <p>Key points covered:</p> <ul> <li>What Babel does in React Native projects.  </li> <li>Metro bundler workflow (and why it defaults to port 8081).  </li> <li>Hot reload vs full reload explained.  </li> </ul> <p>By the end of Part III, you\u2019ll be prepared to handle the ecosystem\u2019s rough edges with practical debugging strategies. Instead of dreading the red error screen, you\u2019ll know how to interpret, resolve, and even prevent common dependency pitfalls. This resilience sets you up for the next stage: building natively with Expo Application Services (EAS).  </p>"},{"location":"PartII_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part II: Getting Started with Your First Project","text":""},{"location":"PartII_overview/#part-ii-getting-started-with-your-first-project","title":"\ud83d\udfe2 Part II: Getting Started with Your First Project","text":"<p>This second part of the book transitions from theory to practice. Here, you\u2019ll scaffold your very first React Native app using Expo, understand the project structure, and begin experimenting with styling through Tailwind (via NativeWind). By the end of this part, you\u2019ll have a running mobile app on both your device and the web, along with a clear grasp of the development feedback loop.</p>"},{"location":"PartII_overview/#chapter-3-scaffolding-a-react-native-app","title":"Chapter 3: Scaffolding a React Native App","text":"<p>This chapter introduces <code>create-expo-app</code>, the official command-line tool for quickly bootstrapping a new project. You\u2019ll learn how the project is generated, what each folder/file means, and how the setup compares to familiar web tooling like CRA or Vite. Finally, we\u2019ll walk through adding Tailwind with NativeWind for rapid UI development.</p> <p>Key points covered:</p> <ul> <li>Using <code>create-expo-app</code> to bootstrap a project.  </li> <li>Explaining the generated project structure.  </li> <li>Adding TailwindCSS styling with NativeWind.  </li> </ul>"},{"location":"PartII_overview/#chapter-4-running-your-app-on-web-and-device","title":"Chapter 4: Running Your App on Web and Device","text":"<p>Once your app is scaffolded, the next step is seeing it in action. This chapter explains how Expo\u2019s development server enables fast iteration with Fast Refresh and Live Reload. You\u2019ll run your app in the browser, test it on a physical device via Expo Go, and learn when it\u2019s time to move to a custom Dev Client.</p> <p>Key points covered:</p> <ul> <li>Fast Refresh &amp; Live Reload basics.  </li> <li>Running your app on a physical device with Expo Go.  </li> <li>Deciding when to switch to a Dev Client for testing.  </li> </ul> <p>By the end of Part II, readers will have gone from zero to a functioning React Native project. They\u2019ll understand the project\u2019s structure, have styling utilities in place, and be confident in running the app across devices. This foundation sets up the more advanced problem-solving lessons in Part III.  </p>"},{"location":"PartIV_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part IV: Building Natively with EAS","text":""},{"location":"PartIV_overview/#part-iv-building-natively-with-eas","title":"\ud83d\udfe2 Part IV: Building Natively with EAS","text":"<p>Up until now, Expo Go has given us an easy way to test apps without touching native code. But as your project grows, you\u2019ll inevitably need more power\u2014custom native modules, deeper debugging, and production-ready builds for the App Store and Play Store. This is where Expo Application Services (EAS) comes in. Part IV of this book guides you through the transition from Expo Go to native builds using EAS, helping you understand its tooling and workflows step by step.</p>"},{"location":"PartIV_overview/#chapter-7-introduction-to-eas-expo-application-services","title":"Chapter 7: Introduction to EAS (Expo Application Services)","text":"<p>This chapter explains why Expo Go alone isn\u2019t enough for serious production apps. You\u2019ll learn what EAS provides, how to install and configure the CLI, and how to work with <code>eas.json</code> to define different build profiles for development, preview, and production.</p> <p>Key points covered:</p> <ul> <li>Why Expo Go can\u2019t cover all production use cases.  </li> <li>Installing and configuring the EAS CLI.  </li> <li>Understanding build profiles in <code>eas.json</code>.  </li> </ul>"},{"location":"PartIV_overview/#chapter-8-your-first-native-build","title":"Chapter 8: Your First Native Build","text":"<p>Here, you\u2019ll run your first actual native build with EAS. Starting with Android, we\u2019ll cover how to generate a development build, install the resulting APK, and test it on your device. You\u2019ll also learn the differences between dev, preview, and production builds so you can choose the right workflow for each stage.</p> <p>Key points covered:</p> <ul> <li>Running <code>eas build -p android --profile development</code>.  </li> <li>Installing and testing a Dev Client APK.  </li> <li>Differences between dev, preview, and production builds.  </li> </ul>"},{"location":"PartIV_overview/#chapter-9-connecting-dev-client-to-metro","title":"Chapter 9: Connecting Dev Client to Metro","text":"<p>Once you\u2019ve built and installed a Dev Client, you\u2019ll need to connect it to your development server (Metro). This chapter covers how to launch Metro in Dev Client mode, use tunnels or hotspots for connectivity, and fall back to USB debugging if needed.</p> <p>Key points covered:</p> <ul> <li>Running <code>expo start --dev-client</code>.  </li> <li>Handling network setups: tunnels, hotspots, and deep links.  </li> <li>Using <code>adb reverse</code> as a fallback for USB connections.  </li> </ul> <p>By the end of Part IV, you\u2019ll be comfortable building native versions of your app, running them on real devices, and connecting them to your development server for iteration. This knowledge bridges the gap between beginner-friendly Expo Go and professional, production-ready mobile development.  </p>"},{"location":"PartI_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part I: Foundations of Cross-Platform Mobile Development","text":""},{"location":"PartI_overview/#part-i-foundations-of-cross-platform-mobile-development","title":"\ud83d\udfe2 Part I: Foundations of Cross-Platform Mobile Development","text":"<p>This first part of the book builds the essential foundation for understanding mobile app development with React Native and Expo. Before diving into scaffolding your first project, it\u2019s important to establish the right mindset for mobile development, clarify how React Native bridges JavaScript with native platforms, and understand the ecosystem Expo provides to simplify the development workflow.</p>"},{"location":"PartI_overview/#chapter-1-why-mobile-feels-different-from-web","title":"Chapter 1: Why Mobile Feels Different from Web","text":"<p>This chapter explores the crucial mindset shift developers must make when transitioning from web to mobile. While React Native lets you reuse your JavaScript and React skills, the environment is fundamentally different\u2014mobile apps run on constrained devices, follow platform-specific guidelines, and must integrate with native APIs. We also introduce how React Native acts as the bridge between your familiar React code and the native UI components rendered on iOS and Android. Finally, we outline the unique role Expo plays in lowering the barrier to entry for mobile developers.</p> <p>Key points covered:</p> <ul> <li>The mindset shift from building for the web to building for mobile.  </li> <li>How React Native bridges JavaScript with native UI rendering.  </li> <li>Expo\u2019s role in making development approachable and efficient.  </li> </ul>"},{"location":"PartI_overview/#chapter-2-the-expo-ecosystem","title":"Chapter 2: The Expo Ecosystem","text":"<p>In this chapter, we dive into the world of Expo itself. Expo provides not only an SDK with prebuilt modules but also a bundling and runtime system that removes the need for complex native setup at the early stages of development. We explore the Metro bundler, the differences between running your project in Expo Go, a Dev Client, or a Production build, and when to use each approach.</p> <p>Key points covered:</p> <ul> <li>Overview of Expo SDK and its prebuilt modules.  </li> <li>Explanation of Metro bundler and its role in development.  </li> <li>Differences between Expo Go, Dev Client, and Production builds.  </li> </ul> <p>By the end of Part I, readers will have a clear understanding of the mental shift required for mobile development, how React Native and Expo complement each other, and what tools are available in the Expo ecosystem. This knowledge sets the stage for starting your first project with confidence in Part II.  </p>"},{"location":"PartV_overview/","title":"&nbsp;&nbsp; \ud83d\udcd6 Part V: Practical Lessons and Next Steps","text":""},{"location":"PartV_overview/#part-v-practical-lessons-and-next-steps","title":"\ud83d\udfe2 Part V: Practical Lessons and Next Steps","text":"<p>With the foundations, scaffolding, and native build workflows behind us, it\u2019s time to turn toward the real-world lessons that separate hobby projects from production-ready apps. This part of the book gathers practical tips, debugging strategies, and forward-looking guidance to help you grow as a mobile developer.</p>"},{"location":"PartV_overview/#chapter-10-tips-from-the-trenches","title":"Chapter 10: Tips from the Trenches","text":"<p>This chapter distills common pitfalls Expo developers face and offers practical advice to avoid them. You\u2019ll learn about project hygiene practices, how to keep your codebase clean, and proven debugging strategies that work under pressure.</p> <p>Key points covered:</p> <ul> <li>Avoiding common Expo pitfalls.  </li> <li>Best practices for keeping projects maintainable.  </li> <li>Debugging strategies that actually work.  </li> </ul>"},{"location":"PartV_overview/#chapter-11-where-to-go-next","title":"Chapter 11: Where to Go Next","text":"<p>Finally, this chapter looks beyond the basics. You\u2019ll explore how to add advanced navigation and UI with React Navigation and NativeWind, work with device features like the camera and file uploads, and prepare your app for deployment on the Play Store and App Store.</p> <p>Key points covered:</p> <ul> <li>Adding navigation and advanced UI components.  </li> <li>Using native APIs such as camera and file handling.  </li> <li>Preparing apps for distribution on app stores.  </li> </ul> <p>By the end of Part V, you\u2019ll have a toolkit of hard-earned lessons and a roadmap for leveling up your mobile development journey. Whether you want to polish your current app or tackle bigger, more ambitious projects, these chapters point you toward sustainable growth as a React Native + Expo developer.</p>"},{"location":"Preface/","title":"&nbsp; Preface","text":""},{"location":"Preface/#why-this-book-exists","title":"Why This Book Exists","text":"<p>Three weeks before writing this, I had never built a mobile app. But while working on ScanlyAI, I went from zero knowledge to deploying a working React Native + Expo app on my Android phone.  </p> <p>That journey taught me a hard truth: Vibe coding is not enough.</p> <p>Here\u2019s what I realized (from a LinkedIn post I wrote during the process):  </p> <ul> <li>\u2705 Vibe coding works great for static sites or small demo projects.  </li> <li>\u2705 It\u2019s fine if you only need simple auth and a few backend endpoints.  </li> <li>\u274c But once your app has 3+ backend services, real integrations, or complex flows\u2014it breaks.  </li> <li>\u274c AI can\u2019t keep up, and you\u2019re left debugging on your own.  </li> </ul> <p>I had to pause, spend a week learning React Native, Expo, and NativeWind properly, and grind through forums, docs, and debugging. Painful? Yes. But necessary.  </p> <p>This book exists because mobile is different from web. The tools look familiar (React, CLI commands, bundlers), but the complexity multiplies once you bring in native dependencies, device testing, and build systems like EAS.  </p> <p>The goal of this handbook is to capture those lessons and distill them into a structured, beginner-to-intermediate guide for anyone stepping into cross-platform mobile development.  </p>"},{"location":"Preface/#who-should-read-this","title":"Who Should Read This","text":"<p>This book is for:</p> <ul> <li>Web developers (React, Vite, CRA, Tailwind) curious about mobile development.  </li> <li>Indie builders and startup founders who want to ship cross-platform apps without drowning in native setup.  </li> <li>Students and career switchers looking for a structured path into mobile engineering.  </li> <li>AI/ML engineers (like myself) who want to wrap models in mobile apps for real-world use cases.  </li> </ul> <p>You don\u2019t need prior mobile experience. Basic React knowledge helps. We\u2019ll cover Expo, EAS, Metro, and the ecosystem step by step.</p>"},{"location":"Preface/#from-web-comfort-to-mobile-reality","title":"From Web Comfort to Mobile Reality","text":"<p>I started with Bolt.new, leaning heavily on Copilot and other AI tools. At first, it felt like coding on autopilot. But once dependency mismatches appeared, everything collapsed.  </p> <p>That\u2019s when I realized: vibe coding is a rocket booster for prototyping, but not a parachute when things get complex.  </p> <p>This book captures that turning point: moving from \u201cAI will fix it for me\u201d to understanding the stack deeply enough to fix it myself.  </p>"},{"location":"Preface/#what-youll-learn-and-what-you-wont","title":"What You\u2019ll Learn (and What You Won\u2019t)","text":"<p>You will learn:</p> <ul> <li>How Expo scaffolds and bundles apps across Android, iOS, and Web.  </li> <li>The difference between Expo Go, Dev Client, and production builds.  </li> <li>How to configure and run EAS cloud builds for real device testing.  </li> <li>How to resolve common dependency/version issues.  </li> <li>How to think like a mobile engineer (not just a web dev).  </li> </ul> <p>You will not find:</p> <ul> <li>Advanced Android/iOS native development tutorials.  </li> <li>In-depth Swift or Kotlin coverage (we\u2019ll stay Expo-first).  </li> <li>Blind \u201ccopy-paste and pray\u201d code snippets with no explanation.  </li> </ul> <p>This is a handbook for builders \u2014 engineers who want to actually ship.  </p>"},{"location":"Preface/#how-to-read-this-book","title":"How to Read This Book","text":"<p>Each chapter includes:</p> <ul> <li>Foundational Concepts: What makes mobile unique compared to web.  </li> <li>Command Cheat Sheets: Key CLI workflows with explanations.  </li> <li>Troubleshooting Tips: Real fixes from real errors I hit.  </li> <li>Code Walkthroughs: Practical examples using Expo + React Native.  </li> <li>Builder\u2019s Notes: Lessons and reflections from the trenches.  </li> </ul> <p>Whether you\u2019re coming from frontend React, backend APIs, or AI/ML, this book will guide you from zero to running your own Dev Client on a real device.  </p>"},{"location":"appendices/","title":"\ud83d\udcd1 Technical Appendices (Cheat Sheets &amp; Guides)","text":"<p>This appendix serves as your quick-access toolkit\u2014a set of references, cheat sheets, and flowcharts you can consult while building apps with React Native, Expo, and EAS. Think of it as the developer\u2019s \u201csurvival pack,\u201d condensing key commands and troubleshooting steps into one place.</p>"},{"location":"appendices/#appendix-a-cli-commands-reference-expo-eas-adb","title":"Appendix A: CLI Commands Reference (Expo, EAS, adb)","text":""},{"location":"appendices/#expo-cli","title":"Expo CLI","text":"<pre><code>npx create-expo-app my-app        # Scaffold a new Expo app\nnpx expo start                    # Start development server\nnpx expo start -c                 # Start and clear Metro cache\nnpx expo install &lt;package&gt;        # Install library with Expo SDK alignment\nnpx expo-doctor                   # Diagnose version/dependency issues\n````\n\n### EAS CLI\n\n```bash\nnpm install -g eas-cli            # Install EAS CLI globally\neas login                         # Authenticate with Expo account\neas build -p android --profile development   # Build for Android dev client\neas build -p ios --profile production        # Build for iOS production\neas submit -p android             # Submit build to Google Play\neas submit -p ios                 # Submit build to Apple App Store\n</code></pre>"},{"location":"appendices/#adb-android-debug-bridge","title":"ADB (Android Debug Bridge)","text":"<pre><code>adb devices                       # List connected Android devices\nadb install myapp.apk             # Install APK on device\nadb reverse tcp:8081 tcp:8081     # Forward Metro traffic via USB\nadb logcat                        # Stream logs for debugging crashes\n</code></pre>"},{"location":"appendices/#appendix-b-comparison-expo-vs-cravite-for-web-devs-crossing-into-mobile","title":"Appendix B: Comparison \u2013 Expo vs CRA/Vite (for Web Devs Crossing into Mobile)","text":"Feature CRA / Vite (Web) Expo (Mobile) Setup Instant scaffold Instant scaffold (<code>create-expo-app</code>) Development server Webpack / Vite Dev Server Metro bundler Hot reload Built-in Fast Refresh &amp; Live Reload Styling CSS, Tailwind React Native styles, NativeWind Native APIs Browser APIs Device APIs (camera, sensors, GPS) Deployment Web hosting (Vercel, Netlify) App stores (EAS + Play/App Store) Distribution Instant via URL Requires APK/IPA builds + reviews"},{"location":"appendices/#appendix-c-troubleshooting-flowchart-metro-builds-dependencies","title":"Appendix C: Troubleshooting Flowchart (Metro, Builds, Dependencies)","text":"<p>Symptom: Red error screen in Metro \u2192 Check error text \u2192 If mentions babel \u2192 confirm <code>babel.config.js</code> setup. \u2192 If mentions worklet/UIManager \u2192 check <code>react-native-reanimated</code> or <code>gesture-handler</code> versions. \u2192 Clear cache with <code>npx expo start -c</code>. \u2192 Still failing? Run <code>expo-doctor</code>.  </p> <p>Symptom: Library won\u2019t install / version mismatch \u2192 Did you use <code>expo install</code> instead of <code>npm install</code>? \u2192 Run <code>expo-doctor</code>. \u2192 Align versions with current Expo SDK release.  </p> <p>Symptom: Device won\u2019t connect to Metro \u2192 Ensure same Wi-Fi network. \u2192 Try tunnel mode (<code>expo start --tunnel</code>). \u2192 Use USB fallback with <code>adb reverse</code>.  </p> <p>Symptom: Build fails in EAS \u2192 Check <code>eas.json</code> for correct profile. \u2192 Confirm credentials (keystore/provisioning). \u2192 Re-run with <code>--clear-cache</code>. \u2192 Search Expo forums for known SDK/version issues.  </p>"},{"location":"appendices/#appendix-d-starter-project-template-expo-nativewind","title":"Appendix D: Starter Project Template (Expo + NativeWind)","text":"<p>A ready-to-use starter template structure:</p> <pre><code>my-app/\n\u251c\u2500\u2500 App.tsx\n\u251c\u2500\u2500 app.json\n\u251c\u2500\u2500 babel.config.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 tailwind.config.js\n\u251c\u2500\u2500 assets/\n\u2502   \u251c\u2500\u2500 icon.png\n\u2502   \u2514\u2500\u2500 splash.png\n\u2514\u2500\u2500 components/\n    \u251c\u2500\u2500 Button.tsx\n    \u251c\u2500\u2500 Card.tsx\n    \u2514\u2500\u2500 Header.tsx\n</code></pre> <p>Sample App.tsx</p>"},{"location":"appendices/#import-tailwindprovider-from-nativewind-import-text-view-from-react-native-export-default-function-app-return-tailwindprovider-view-classnameflex-1-items-center-justify-center-bg-gray-100-text-classnametext-lg-font-bold-text-indigo-600-hello-expo-nativewind-text-view-tailwindprovider","title":"<pre><code>import { TailwindProvider } from \"nativewind\";\nimport { Text, View } from \"react-native\";\n\nexport default function App() {\n  return (\n    &lt;TailwindProvider&gt;\n      &lt;View className=\"flex-1 items-center justify-center bg-gray-100\"&gt;\n        &lt;Text className=\"text-lg font-bold text-indigo-600\"&gt;\n          Hello, Expo + NativeWind!\n        &lt;/Text&gt;\n      &lt;/View&gt;\n    &lt;/TailwindProvider&gt;\n  );\n}\n</code></pre>","text":""},{"location":"appendices/#recommended-resources","title":"Recommended Resources","text":"<p>These are trusted external resources to help you explore deeper and learn more beyond this book:</p> Topic Resource React Native Docs reactnative.dev Expo Documentation docs.expo.dev React Navigation reactnavigation.org Babel Basics babeljs.io Metro Bundler (GitHub) Metro GitHub / metro-bundler <p>These resources complement the explanations in the book with official guides, API references, and deeper context. Bookmark them as your go-to for reliable documentation, community best practices, and the latest updates in your mobile development journey.</p>"},{"location":"appendices/#final-note","title":"\u2705 Final Note","text":"<p>These appendices are designed for speed and clarity. Keep them close while building\u2014whether you\u2019re debugging a stubborn Metro error, recalling an EAS command, or scaffolding a fresh project with Tailwind.</p> <p>They\u2019re not meant to replace the detailed explanations from earlier chapters\u2014but to give you a practical reference when you need answers fast.</p>"},{"location":"chapter1/","title":"Chapter 1: Why Mobile Feels Different from Web","text":"<p>Before diving into code and project scaffolding, it\u2019s worth pausing to reflect on why building for mobile feels fundamentally different from building for the web. Many developers enter React Native with strong React or JavaScript backgrounds, expecting a smooth continuation of familiar workflows. Yet, the mobile world comes with its own constraints, philosophies, and technical nuances. This chapter explores that mindset shift, introduces how React Native serves as a bridge between JavaScript and native UI, and clarifies Expo\u2019s role in easing the developer journey.</p>"},{"location":"chapter1/#the-web-vs-mobile-mindset-shift","title":"The Web vs. Mobile Mindset Shift","text":""},{"location":"chapter1/#the-web-developers-comfort-zone","title":"The Web Developer\u2019s Comfort Zone","text":"<p>On the web, developers are accustomed to a fast feedback loop: save your file, refresh the browser, and see immediate results. Browsers handle a remarkable amount of complexity for you\u2014cross-platform rendering, network requests, caching, and even responsive design through CSS. You rarely need to worry about what\u2019s happening under the hood of the operating system.</p>"},{"location":"chapter1/#mobile-reality","title":"Mobile Reality","text":"<p>Mobile apps, however, operate under different constraints:  </p> <ul> <li>Performance budgets are tighter\u2014phones have limited memory, battery, and CPU.  </li> <li>Platform guidelines (iOS Human Interface Guidelines, Android Material Design) shape how apps should look and behave.  </li> <li>Native APIs\u2014from the camera to GPS to push notifications\u2014require bridging between JavaScript and the host OS.  </li> <li>Distribution happens through app stores, with review processes and update cycles that don\u2019t exist on the open web.  </li> </ul> <p>These differences demand a shift in mindset: you\u2019re not just rendering UI anymore\u2014you\u2019re building for an ecosystem with strict rules and real-world limitations.</p>"},{"location":"chapter1/#react-native-bridging-javascript-and-native-ui","title":"React Native: Bridging JavaScript and Native UI","text":""},{"location":"chapter1/#the-bridge-concept","title":"The Bridge Concept","text":"<p>React Native enables developers to write JavaScript (and often TypeScript) while rendering native UI components under the hood. Instead of shipping a web view inside an app, React Native uses a \u201cbridge\u201d to connect your JavaScript logic to native modules. For example:  </p> <ul> <li>A <code>&lt;Text&gt;</code> component maps to a UILabel on iOS or a TextView on Android.  </li> <li>A <code>&lt;View&gt;</code> translates to UIView (iOS) or ViewGroup (Android).  </li> </ul> <p>This approach ensures apps feel native in performance and look, while letting you leverage the reactivity of React.</p>"},{"location":"chapter1/#benefits-and-trade-offs","title":"Benefits and Trade-offs","text":"<ul> <li>Pros: Shared codebase across iOS/Android, strong React ecosystem, quicker iteration.  </li> <li>Cons: Occasional \u201cbridge bottlenecks,\u201d compatibility issues with some native libraries, and reliance on the health of the React Native ecosystem.  </li> </ul> <p>Understanding this bridge model is crucial\u2014it helps developers appreciate both the power and limitations of React Native.</p>"},{"location":"chapter1/#understanding-expos-role","title":"Understanding Expo\u2019s Role","text":""},{"location":"chapter1/#why-expo-exists","title":"Why Expo Exists","text":"<p>Expo sits on top of React Native, smoothing out many of the pain points new developers encounter. Instead of wrestling with Xcode or Android Studio configurations just to run a \u201cHello World\u201d app, Expo provides:  </p> <ul> <li>Expo SDK \u2013 prebuilt modules for camera, notifications, sensors, and more.  </li> <li>Expo Go app \u2013 a lightweight way to preview your app instantly on a physical device without compiling native code.  </li> <li>Unified tooling \u2013 commands like <code>npx create-expo-app</code> simplify project setup.  </li> </ul>"},{"location":"chapter1/#developer-experience-gains","title":"Developer Experience Gains","text":"<p>For beginners, Expo provides a sandboxed environment that just works. For professionals, it streamlines prototyping and accelerates iteration. Eventually, when advanced customization is needed, you can \u201ceject\u201d to full native builds or transition into using Expo Application Services (EAS).</p>"},{"location":"chapter1/#conclusion-the-foundation-laid","title":"Conclusion: The Foundation Laid","text":"<p>This opening chapter laid out why building for mobile differs from the web, how React Native enables JavaScript developers to step into native app development, and how Expo lowers the barrier to entry. Understanding these three pillars\u2014the mindset shift, the React Native bridge, and Expo\u2019s role\u2014sets the stage for exploring the Expo ecosystem in detail in the next chapter.</p>"},{"location":"chapter10/","title":"Chapter 10: Tips from the Trenches","text":"<p>Every developer who spends enough time with React Native and Expo learns the same lesson: the official docs are only half the story. The other half comes from mistakes made at 2 AM, debugging cryptic Metro errors, or chasing version mismatches through GitHub issues. This chapter gathers those battle-tested lessons so you don\u2019t have to stumble through every pitfall yourself.</p>"},{"location":"chapter10/#avoiding-common-expo-pitfalls","title":"Avoiding Common Expo Pitfalls","text":""},{"location":"chapter10/#pitfall-1-ignoring-sdk-versions","title":"Pitfall 1: Ignoring SDK Versions","text":"<p>Expo is versioned tightly, and your project depends on the specific SDK release you\u2019re using. Installing a random NPM package version is the fastest way to break your build.</p> <p>Tip: Always use:</p> <pre><code>expo install &lt;package-name&gt;\n````\n\nThis ensures Expo aligns the installed version with your SDK.\n\n---\n\n### Pitfall 2: Relying Too Long on Expo Go\n\nExpo Go is fantastic for prototypes, but it can give you a false sense of security. Features may work in Expo Go but fail in a Dev Client or production build.\n\n**Tip:** Transition to a Dev Client early once you add any native dependencies. Don\u2019t wait until release week.\n\n---\n\n### Pitfall 3: Forgetting to Clear Caches\n\nMetro\u2019s cache can hold onto broken states. If you\u2019re debugging an error that *shouldn\u2019t exist*, the cache may be to blame.\n\n**Tip:** Run:\n\n```bash\nnpx expo start -c\n</code></pre> <p>to clear caches before spending hours chasing phantom issues.</p>"},{"location":"chapter10/#best-practices-for-project-hygiene","title":"Best Practices for Project Hygiene","text":""},{"location":"chapter10/#keep-your-dependencies-lean","title":"Keep Your Dependencies Lean","text":"<p>Each library you add increases the chance of version conflicts. Resist the temptation to install \u201cjust one more\u201d package for something you could implement with plain React Native.</p>"},{"location":"chapter10/#organize-your-components","title":"Organize Your Components","text":"<p>Split components into <code>/components</code> and group related features. This reduces clutter and keeps you from getting lost in a sea of <code>App.js</code> spaghetti.</p>"},{"location":"chapter10/#version-control-discipline","title":"Version Control Discipline","text":"<p>Always commit a working state before experimenting. Expo projects can break suddenly, and having a safe checkpoint saves you from painful rollbacks.</p>"},{"location":"chapter10/#debugging-strategies-that-actually-work","title":"Debugging Strategies That Actually Work","text":""},{"location":"chapter10/#strategy-1-start-simple","title":"Strategy 1: Start Simple","text":"<p>When faced with a red error screen, your instinct may be to dive into Stack Overflow. Instead, strip the problem down: comment out code until the error disappears, then reintroduce parts systematically. Often, the culprit reveals itself faster than endless Googling.</p>"},{"location":"chapter10/#strategy-2-read-the-logs-closely","title":"Strategy 2: Read the Logs Closely","text":"<p>Expo and Metro errors often contain hidden clues. Look for specific words like <code>babel</code>, <code>worklet</code>, or <code>UIManager</code>\u2014these usually point you toward the real issue.</p>"},{"location":"chapter10/#strategy-3-know-when-to-rebuild","title":"Strategy 3: Know When to Rebuild","text":"<p>If your app behaves differently in Expo Go and Dev Client, the issue often lies in native bindings. Rebuild with:</p> <pre><code>eas build -p android --profile development\n</code></pre> <p>to confirm whether the bug is JavaScript-only or native-related.</p>"},{"location":"chapter10/#conclusion-wisdom-from-the-field","title":"Conclusion: Wisdom from the Field","text":"<p>By avoiding common pitfalls, maintaining project hygiene, and applying systematic debugging, you\u2019ll spend less time stuck and more time building features. The truth is, no developer completely avoids dependency hell or red error screens\u2014but seasoned developers recover faster because they\u2019ve built habits that minimize the damage.</p> <p>In the next chapter, we\u2019ll zoom out and talk about what comes after the basics: advanced UI, navigation, working with device APIs, and preparing your app for distribution on app stores.</p>"},{"location":"chapter11/","title":"Chapter 11: Where to Go Next","text":"<p>Reaching this point means you\u2019ve built, styled, debugged, and even deployed native builds of your app. But mobile development doesn\u2019t end at \u201cit runs.\u201d The real growth comes from pushing your apps further\u2014adding richer navigation, accessing device capabilities, and preparing them for the rigor of app store deployment. This chapter points you toward those next steps.</p>"},{"location":"chapter11/#adding-navigation-and-advanced-ui","title":"Adding Navigation and Advanced UI","text":""},{"location":"chapter11/#react-navigation","title":"React Navigation","text":"<p>Most real apps need more than a single screen. React Navigation is the go-to library for handling stacks, tabs, and drawer navigation in React Native.</p> <p>Example setup for a stack navigator:</p> <pre><code>import { createNativeStackNavigator } from '@react-navigation/native-stack';\nimport { NavigationContainer } from '@react-navigation/native';\n\nconst Stack = createNativeStackNavigator();\n\nexport default function App() {\n  return (\n    &lt;NavigationContainer&gt;\n      &lt;Stack.Navigator&gt;\n        &lt;Stack.Screen name=\"Home\" component={HomeScreen} /&gt;\n        &lt;Stack.Screen name=\"Details\" component={DetailScreen} /&gt;\n      &lt;/Stack.Navigator&gt;\n    &lt;/NavigationContainer&gt;\n  );\n}\n````\n\nWith this, you can transition between screens just like native apps do, complete with smooth animations.\n\n### Advanced Styling with NativeWind\n\nIf you\u2019ve used Tailwind on the web, **NativeWind** lets you carry over that same utility-first styling into React Native. Combined with React Navigation, it enables building polished UIs quickly, without drowning in verbose style objects.\n\n---\n\n## Camera, File Upload, and Native APIs\n\n### Accessing the Camera\n\nUsing Expo SDK modules, you can integrate device features like the camera:\n\n```tsx\nimport { CameraView } from 'expo-camera';\n\n&lt;CameraView style={{ flex: 1 }} /&gt;\n</code></pre> <p>From barcode scanning to document capture, the camera is one of the most common native integrations.</p>"},{"location":"chapter11/#file-uploads","title":"File Uploads","text":"<p>With libraries like <code>expo-document-picker</code> or <code>expo-image-picker</code>, you can let users upload files or images. This is often paired with backend APIs to store or process the uploaded data.</p>"},{"location":"chapter11/#beyond-expo-sdk","title":"Beyond Expo SDK","text":"<p>At some point, you\u2019ll outgrow Expo\u2019s built-in modules. That\u2019s when Dev Clients and custom native modules become essential, giving you access to the full range of platform-specific APIs.</p>"},{"location":"chapter11/#preparing-for-play-store-and-app-store-deployment","title":"Preparing for Play Store and App Store Deployment","text":""},{"location":"chapter11/#the-reality-of-store-guidelines","title":"The Reality of Store Guidelines","text":"<p>Unlike web apps, mobile apps must pass through review processes before users can install them. Both Google Play and Apple\u2019s App Store have strict requirements around app quality, privacy, and design.</p>"},{"location":"chapter11/#deployment-workflow","title":"Deployment Workflow","text":"<ol> <li>Build production-ready binaries with EAS:</li> </ol> <pre><code>eas build -p android --profile production\neas build -p ios --profile production\n</code></pre> <ol> <li>Submit builds directly using EAS Submit:</li> </ol> <pre><code>eas submit -p android\neas submit -p ios\n</code></pre> <ol> <li>Address any review feedback and resubmit as needed.</li> </ol>"},{"location":"chapter11/#best-practices","title":"Best Practices","text":"<ul> <li>Prepare polished icons and splash screens.</li> <li>Test thoroughly on both iOS and Android devices.</li> <li>Follow platform-specific UI/UX conventions for better acceptance chances.</li> </ul>"},{"location":"chapter11/#conclusion-the-path-forward","title":"Conclusion: The Path Forward","text":"<p>The journey from web developer comfort zones to deploying full-fledged mobile apps is challenging but deeply rewarding. With React Native, Expo, and EAS, you\u2019ve learned how to build, test, debug, and ship apps that run on real devices.</p> <p>From here, your growth depends on practice and exploration: build side projects, experiment with native APIs, and eventually push into areas like performance optimization, offline-first design, or even integrating AI models into your mobile apps.</p> <p>This book has given you a foundation\u2014now it\u2019s up to you to expand it, one app at a time.</p>"},{"location":"chapter2/","title":"Chapter 2: The Expo Ecosystem","text":"<p>Now that we\u2019ve explored why mobile development feels different from the web and how React Native bridges JavaScript with native UI, it\u2019s time to look closely at Expo. For many developers, Expo is the real gateway into the mobile world. It removes much of the friction of setting up iOS and Android environments and provides an ecosystem of tools, services, and SDKs that accelerate development. In this chapter, we\u2019ll explore the Expo SDK, understand the role of Metro bundler, and clarify the differences between Expo Go, Dev Client, and Production builds.</p>"},{"location":"chapter2/#expo-sdk-and-prebuilt-modules","title":"Expo SDK and Prebuilt Modules","text":""},{"location":"chapter2/#what-is-the-expo-sdk","title":"What is the Expo SDK?","text":"<p>The Expo SDK is a curated set of prebuilt modules that handle common mobile needs\u2014camera access, image picking, push notifications, location tracking, secure storage, sensors, haptics, and more. Instead of manually linking native dependencies or writing Objective-C/Java code, developers can simply install and import these modules.</p> <p>Example: ```tsx import * as ImagePicker from 'expo-image-picker';</p> <p>const result = await ImagePicker.launchCameraAsync({   mediaTypes: ImagePicker.MediaTypeOptions.Images,   allowsEditing: true, }); ````</p> <p>This single call abstracts away the complexity of interacting with native camera APIs. The Expo SDK is especially powerful for rapid prototyping, where speed of iteration matters more than fine-grained customization.</p>"},{"location":"chapter2/#benefits-of-the-sdk","title":"Benefits of the SDK","text":"<ul> <li>Consistency \u2013 Works across iOS and Android without needing two separate implementations.</li> <li>Faster Development \u2013 Common features like notifications or permissions are a single import away.</li> <li>Community Trust \u2013 Maintained and tested by Expo, reducing the chances of version conflicts.</li> </ul>"},{"location":"chapter2/#metro-bundler-explained","title":"Metro Bundler Explained","text":""},{"location":"chapter2/#what-is-metro","title":"What is Metro?","text":"<p>Under the hood, React Native apps (Expo or not) are powered by Metro, a JavaScript bundler. Metro watches your files, compiles modern JavaScript/TypeScript, and sends updates to your app in real time. It\u2019s what makes features like Fast Refresh possible.</p> <p>Think of Metro as the \u201cWebpack of React Native,\u201d optimized for mobile. It serves code over a development server (often at <code>localhost:8081</code>), which your device or simulator connects to.</p>"},{"location":"chapter2/#developer-workflow-with-metro","title":"Developer Workflow with Metro","text":"<ul> <li>Change your code \u2192 Metro recompiles.</li> <li>Metro pushes the update to your app without a full rebuild.</li> <li>Errors appear instantly in red error screens, helping you debug faster.</li> </ul> <p>Without Metro, iteration in mobile would be painfully slow\u2014rebuilding and reinstalling the app for every change.</p>"},{"location":"chapter2/#expo-go-vs-dev-client-vs-production","title":"Expo Go vs. Dev Client vs. Production","text":"<p>One of the most common questions new developers face: \u201cShould I run this in Expo Go, build a Dev Client, or create a Production build?\u201d Each has its role.</p>"},{"location":"chapter2/#expo-go","title":"Expo Go","text":"<ul> <li>What it is: A sandbox app (downloadable from App Store/Play Store) that runs your project via QR code.</li> <li>Best for: Early development, prototyping, or demoing apps quickly.</li> <li>Limitations: Can only use Expo SDK modules; custom native code isn\u2019t supported.</li> </ul>"},{"location":"chapter2/#dev-client","title":"Dev Client","text":"<ul> <li>What it is: A custom build of your app with the Expo runtime, plus any extra native modules you need.</li> <li>Best for: Testing features not available in Expo Go (e.g., third-party native packages).</li> <li>Setup: Built using EAS Build and installed on your device.</li> </ul>"},{"location":"chapter2/#production-build","title":"Production Build","text":"<ul> <li>What it is: The final packaged app submitted to the App Store or Play Store.</li> <li>Best for: Distributing apps to real users.</li> <li>Differences: No debugging overlays, optimized for performance, and bundled with release keys.</li> </ul>"},{"location":"chapter2/#conclusion-choosing-the-right-tool","title":"Conclusion: Choosing the Right Tool","text":"<p>Expo isn\u2019t just a convenience layer\u2014it\u2019s an ecosystem designed to streamline your journey from idea to production-ready app. The SDK modules let you move quickly, Metro powers your development feedback loop, and the choice between Expo Go, Dev Client, and Production builds ensures you always have the right tool for the stage of development you\u2019re in.</p> <p>With this understanding of Expo\u2019s ecosystem, you\u2019re now ready to scaffold your very first React Native project in Part II, starting with <code>create-expo-app</code>.</p>"},{"location":"chapter3/","title":"Chapter 3: Scaffolding a React Native App","text":"<p>Every great app begins with a scaffold. In the web world, you may have used <code>create-react-app</code> or Vite to spin up a project quickly. In the mobile world, Expo provides a similar tool: <code>create-expo-app</code>. This chapter walks you through creating your first React Native project, understanding the structure it generates, and setting up styling with Tailwind via NativeWind. By the end, you\u2019ll not only have a functioning project but also a clear sense of the moving parts.</p>"},{"location":"chapter3/#using-create-expo-app","title":"Using <code>create-expo-app</code>","text":""},{"location":"chapter3/#why-a-scaffolding-tool","title":"Why a Scaffolding Tool?","text":"<p>Instead of manually configuring React Native, Metro, and platform-specific code, Expo\u2019s scaffolding tool gives you a ready-to-run project in one command. This is especially helpful if you\u2019re just starting\u2014no need to wrestle with Xcode or Android Studio before writing your first component.</p>"},{"location":"chapter3/#the-command","title":"The Command","text":"<p>Run this in your terminal:</p> <p><pre><code>npx create-expo-app my-first-app\ncd my-first-app\nnpm start\n````\n\nThis initializes a new Expo project named `my-first-app`. The `npm start` command launches Expo\u2019s development server, which provides you with a QR code you can scan using Expo Go or your Dev Client.\n\n### First Impressions\n\nIf everything works, you\u2019ll see a basic \u201cOpen up App.js to start working on your app!\u201d screen. It might feel underwhelming at first, but this minimal starting point is intentional\u2014it keeps you in control of shaping the app\u2019s direction.\n\n## Project Structure Explained\n\nAfter scaffolding, your folder might look like this:\n</code></pre> my-first-app/ \u251c\u2500\u2500 App.js \u251c\u2500\u2500 app.json \u251c\u2500\u2500 babel.config.js \u251c\u2500\u2500 package.json \u251c\u2500\u2500 node_modules/ \u2514\u2500\u2500 assets/ <pre><code>Let\u2019s break this down:\n\n* **App.js** \u2013 The root of your React Native app; equivalent to `index.js` in web React projects.\n* **app.json** \u2013 Expo configuration file (name, slug, splash screen, icons, etc.).\n* **babel.config.js** \u2013 Configures Babel for transforming modern JavaScript into code Metro can bundle.\n* **package.json** \u2013 Lists dependencies and scripts, just like in a Node project.\n* **assets/** \u2013 Place for static files such as images and fonts.\n\nCompared to web tooling, the structure is leaner. Most of the heavy lifting (like Webpack configs in web apps) is abstracted away by Expo.\n\n## Adding Tailwind with NativeWind\n\n### Why Tailwind on Mobile?\n\nStyling in React Native can feel verbose since there\u2019s no CSS\u2014styles are objects in JavaScript. Tailwind, adapted via **NativeWind**, gives you the utility-first styling approach you might already love from web projects.\n\n### Installation\n\nFrom your project root, run:\n\n```bash\nnpm install nativewind tailwindcss\nnpx tailwindcss init\n</code></pre></p> <p>Update your tailwind.config.js:</p> <pre><code>module.exports = {\n  content: [\"./App.{js,jsx,ts,tsx}\", \"./components/**/*.{js,jsx,ts,tsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\n</code></pre> <p>Then wrap your app in the NativeWind provider:</p> <pre><code>import { TailwindProvider } from \"nativewind\";\n\nexport default function App() {\n  return (\n    &lt;TailwindProvider&gt;\n      &lt;Text className=\"text-lg font-bold text-blue-500\"&gt;Hello Expo + Tailwind!&lt;/Text&gt;\n    &lt;/TailwindProvider&gt;\n  );\n}\n</code></pre>"},{"location":"chapter3/#the-payoff","title":"The Payoff","text":"<p>With Tailwind in place, styling becomes concise and expressive. Instead of defining a <code>StyleSheet</code> for everything, you can rapidly prototype with classes like <code>p-4</code>, <code>bg-indigo-500</code>, or <code>rounded-xl</code>.</p>"},{"location":"chapter3/#conclusion-first-building-block-complete","title":"Conclusion: First Building Block Complete","text":"<p>By scaffolding with <code>create-expo-app</code>, you\u2019ve taken the first real step into mobile development. You\u2019ve learned how to interpret the project structure and even enhanced styling with NativeWind. This foundation prepares you for the next step: running your app on devices and understanding the development feedback loop, which we\u2019ll explore in Chapter 4.</p>"},{"location":"chapter4/","title":"Chapter 4: Running Your App on Web and Device","text":"<p>After scaffolding your first Expo project, the next natural step is to see it in action. Unlike the web, where you simply refresh a browser tab, mobile development involves simulators, physical devices, and even browsers for testing. This chapter walks you through Expo\u2019s development workflow, explains Fast Refresh and Live Reload, and helps you decide when to use Expo Go versus a custom Dev Client.</p>"},{"location":"chapter4/#fast-refresh-live-reload-basics","title":"Fast Refresh &amp; Live Reload Basics","text":""},{"location":"chapter4/#the-developer-feedback-loop","title":"The Developer Feedback Loop","text":"<p>In web projects, you\u2019re used to hitting save and seeing instant changes in your browser. Expo provides a similar experience through Fast Refresh and Live Reload:</p> <ul> <li>Fast Refresh: Only re-renders the files you edited, preserving app state when possible. For example, editing the text inside a component updates the UI instantly without losing the current screen.  </li> <li>Live Reload: Reloads the entire app when files change, ensuring a full refresh but resetting state. Useful if you make structural changes that Fast Refresh can\u2019t handle.  </li> </ul> <p>These tools make mobile development feel much closer to web development\u2014fast, iterative, and forgiving.</p>"},{"location":"chapter4/#example-in-action","title":"Example in Action","text":"<ol> <li>Run your app with:</li> </ol> <p>```bash    npm start ````</p> <ol> <li>Open it on your device or simulator.</li> <li>Edit <code>App.js</code>\u2014for example, change the default text.</li> </ol> <p>Your changes appear within seconds, either preserving your current screen (Fast Refresh) or fully reloading (Live Reload).</p>"},{"location":"chapter4/#running-with-expo-go-on-physical-devices","title":"Running with Expo Go on Physical Devices","text":""},{"location":"chapter4/#what-is-expo-go","title":"What is Expo Go?","text":"<p>Expo Go is a sandbox app available on the App Store and Google Play. It lets you open your project instantly by scanning a QR code from the terminal or Expo Developer Tools in your browser. No builds, no Xcode, no Android Studio required.</p>"},{"location":"chapter4/#workflow","title":"Workflow","text":"<ol> <li> <p>Install Expo Go on your phone.</p> </li> <li> <p>Run:</p> </li> </ol> <pre><code>npm start\n</code></pre> <ol> <li> <p>Scan the QR code with Expo Go.</p> </li> <li> <p>Your project runs on your actual device.</p> </li> </ol> <p>This workflow is invaluable for testing touch, camera, and performance on real hardware.</p>"},{"location":"chapter4/#limitations-of-expo-go","title":"Limitations of Expo Go","text":"<p>While Expo Go is fantastic for quick iteration, it only supports modules included in the Expo SDK. If you need custom native code or third-party modules not in the SDK, you\u2019ll need to move to a Dev Client.</p>"},{"location":"chapter4/#when-and-why-to-switch-to-dev-client","title":"When and Why to Switch to Dev Client","text":""},{"location":"chapter4/#dev-client-defined","title":"Dev Client Defined","text":"<p>A Dev Client is a custom build of your app with Expo\u2019s development runtime and any extra native modules you include. It bridges the gap between the ease of Expo Go and the flexibility of full native builds.</p>"},{"location":"chapter4/#when-to-use-it","title":"When to Use It","text":"<ul> <li>You\u2019ve installed a native dependency not supported by Expo Go (e.g., advanced Bluetooth, payments, AR libraries).</li> <li>You need to debug issues closer to the native layer.</li> <li>You\u2019re preparing for production and want a build that mirrors your final app.</li> </ul>"},{"location":"chapter4/#how-to-get-it","title":"How to Get It","text":"<p>You\u2019ll create Dev Clients using EAS Build, which we\u2019ll cover in detail in Part IV. For now, just remember: Expo Go is for speed, Dev Client is for power.</p>"},{"location":"chapter4/#conclusion-testing-across-web-and-device","title":"Conclusion: Testing Across Web and Device","text":"<p>In this chapter, you learned how Expo\u2019s feedback loop keeps development smooth with Fast Refresh and Live Reload. You saw how Expo Go enables real-device testing without heavy setup, and when to graduate to Dev Client builds. With these tools, your workflow is flexible: iterate quickly, test broadly, and escalate only when necessary.</p> <p>This concludes Part II. In the next part, we\u2019ll face the unavoidable realities of mobile development\u2014dependency hell\u2014and learn how to survive it with the right tools and mindset.</p>"},{"location":"chapter5/","title":"Chapter 5: Library Compatibility Issues","text":"<p>If you spend enough time building with React Native and Expo, you\u2019ll eventually encounter what developers lovingly call \u201cdependency hell.\u201d It\u2019s that moment when you install a library, eager to test a new feature, only to be greeted by walls of cryptic red errors. Unlike the web, where most packages are pure JavaScript, mobile libraries often involve native code bindings, and this is where things get messy.</p> <p>In this chapter, we\u2019ll explore why some libraries cause more problems than others, how Expo\u2019s tooling helps you keep versions aligned, and how to interpret errors so you don\u2019t get lost in the chaos.</p>"},{"location":"chapter5/#common-problem-packages","title":"Common Problem Packages","text":""},{"location":"chapter5/#the-case-of-react-native-reanimated","title":"The Case of <code>react-native-reanimated</code>","text":"<p>One of the most powerful libraries in the ecosystem, <code>react-native-reanimated</code>, allows for buttery-smooth animations by running code directly on the native thread. But because it sits so close to the native layer, it is often sensitive to version mismatches.</p> <p>Symptoms of version issues:  </p> <ul> <li>Blank screens when running animations.  </li> <li>Metro errors like \u201cCannot find node in UIManager\u201d.  </li> <li>Build failures on iOS/Android when versions don\u2019t align.  </li> </ul>"},{"location":"chapter5/#react-native-gesture-handler","title":"<code>react-native-gesture-handler</code>","text":"<p>Another essential yet finicky package is <code>react-native-gesture-handler</code>. It underpins navigation and complex touch gestures in React Native apps. Like <code>reanimated</code>, it often breaks if you mix incompatible versions with React Native or Expo.</p> <p>Symptoms:  </p> <ul> <li>Crashes when navigating between screens.  </li> <li>Errors such as \u201cModule not found: GestureHandler\u201d.  </li> <li>Gestures silently failing without logs.  </li> </ul> <p>Together, these two libraries account for a large portion of developer headaches\u2014but they\u2019re also indispensable. Mastering them is part of the journey.</p>"},{"location":"chapter5/#expos-safety-nets-expo-install","title":"Expo\u2019s Safety Nets: <code>expo install</code>","text":"<p>A common pitfall for beginners is using <code>npm install</code> or <code>yarn add</code> directly when adding libraries. While this works fine on the web, it can backfire in React Native because not all versions of a package are compatible with your current Expo/React Native version.</p> <p>Instead, use:</p> <pre><code>expo install react-native-reanimated\n````\n\nUnlike `npm install`, this command automatically installs the **correct version** aligned with your current Expo SDK. Think of it as Expo\u2019s built-in guardrail against version mismatches.\n\n## Checking Health with `expo-doctor`\n\nWhen things still go wrong (and they will), `expo-doctor` is your friend:\n\n```bash\nnpx expo-doctor\n</code></pre> <p>This command scans your project for dependency mismatches, incompatible native modules, and other red flags. It doesn\u2019t fix everything automatically, but it gives you a roadmap of what\u2019s broken.</p> <p>Example output might look like:</p> <pre><code>[WARN] react-native-reanimated@3.4.2 expected, found 3.3.0\n[ERROR] expo-sqlite is missing native module bindings\n</code></pre> <p>From there, you\u2019ll know whether to upgrade, downgrade, or reinstall a package.</p>"},{"location":"chapter5/#how-to-interpret-metros-red-errors","title":"How to Interpret Metro\u2019s Red Errors","text":""},{"location":"chapter5/#the-panic-moment","title":"The Panic Moment","text":"<p>Metro errors often feel like they\u2019re yelling at you: giant red screens with long stack traces. The key is to slow down and read them carefully.</p> <p>For example:</p> <pre><code>Error: Reanimated 3 failed to create a worklet, maybe you forgot to add Reanimated's babel plugin?\n</code></pre> <p>The fix is often hidden in the error itself\u2014in this case, adding the plugin to <code>babel.config.js</code>.</p>"},{"location":"chapter5/#debugging-mindset","title":"Debugging Mindset","text":"<ul> <li>Step 1: Ask: Is this a JavaScript-only package or does it bridge into native code?</li> <li>Step 2: If native, check version alignment with <code>expo install</code>.</li> <li>Step 3: Run <code>expo-doctor</code> to confirm mismatches.</li> <li>Step 4: Clear caches (<code>npx expo start -c</code>) before retrying.</li> </ul> <p>Most issues can be resolved with patience and version discipline.</p>"},{"location":"chapter5/#conclusion-taming-the-beast","title":"Conclusion: Taming the Beast","text":"<p>Dependency hell isn\u2019t a bug\u2014it\u2019s a feature of working with a diverse ecosystem that blends JavaScript with native code. By recognizing common offenders, relying on Expo\u2019s <code>expo install</code> guardrails, and using <code>expo-doctor</code> for diagnosis, you\u2019ll transform frustration into a manageable process.</p> <p>In the next chapter, we\u2019ll dive deeper into the tooling behind the scenes\u2014Babel and Metro\u2014so you understand why some errors appear and how the development pipeline really works.</p>"},{"location":"chapter6/","title":"Chapter 6: Babel, Metro, and You","text":"<p>If Chapter 5 was about taming external libraries, this chapter is about peeking under the hood of your own project. Many of the infamous red error screens that developers encounter don\u2019t actually come from their app\u2019s logic\u2014but from the build pipeline powered by Babel and Metro. Understanding how these tools work gives you clarity when debugging and helps you avoid chasing shadows.</p>"},{"location":"chapter6/#what-babel-does-in-react-native-projects","title":"What Babel Does in React Native Projects","text":""},{"location":"chapter6/#javascript-beyond-the-browser","title":"JavaScript Beyond the Browser","text":"<p>React Native apps are written in modern JavaScript (or TypeScript), but mobile devices can\u2019t directly run features like optional chaining, async/await, or JSX. That\u2019s where Babel comes in\u2014it transpiles your code into a form that Metro and the native runtime can understand.</p> <p>For example:  </p> <pre><code>const userName = user?.profile?.name ?? \"Guest\";\n````\n\nBabel rewrites this into older JavaScript that\u2019s safe to run on React Native\u2019s JavaScript engine.\n\n### Plugins and Presets\n\nBabel uses **plugins** and **presets** to transform your code. A common culprit for errors is a missing or misconfigured plugin. For example, `react-native-reanimated` requires a custom Babel plugin\u2014if you forget to add it, you\u2019ll get cryptic \u201cworklet\u201d errors.\n\nYour `babel.config.js` might look like:\n\n```js\nmodule.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: ['babel-preset-expo'],\n    plugins: ['react-native-reanimated/plugin'],\n  };\n};\n</code></pre> <p>Without the right setup, Metro will happily compile your code but crash when executing it.</p>"},{"location":"chapter6/#metro-bundler-workflow-port-8081","title":"Metro Bundler Workflow (Port 8081)","text":""},{"location":"chapter6/#what-metro-is","title":"What Metro Is","text":"<p>Think of Metro as the \u201cWebpack for React Native.\u201d Its job is to bundle all your JavaScript, assets, and dependencies into a format that the mobile runtime can load.</p> <ul> <li>It watches files for changes.</li> <li>It transforms code using Babel.</li> <li>It serves bundles to your app over a local dev server (default: <code>http://localhost:8081</code>).</li> </ul> <p>That\u2019s why you\u2019ll often see your app connect to port 8081 when running in development.</p>"},{"location":"chapter6/#how-metro-speeds-you-up","title":"How Metro Speeds You Up","text":"<p>Metro is optimized for mobile workflows:</p> <ul> <li>Incremental builds: Only recompiles changed files.</li> <li>Fast Refresh: Pushes changes to your app without a full reload.</li> <li>Asset bundling: Handles images, fonts, and static files.</li> </ul> <p>When errors occur, Metro is usually the messenger\u2014it\u2019s telling you something went wrong in compilation or bundling.</p>"},{"location":"chapter6/#hot-reload-vs-full-reload","title":"Hot Reload vs. Full Reload","text":""},{"location":"chapter6/#hot-reload-fast-refresh","title":"Hot Reload (Fast Refresh)","text":"<p>When you save changes, Metro updates only the affected modules. This preserves app state where possible\u2014useful if you\u2019re debugging inside a form or on a deep screen in your navigation stack.</p> <p>Example: Change text from \u201cHello World\u201d to \u201cHello Expo\u201d \u2192 The UI updates instantly, without restarting the app.</p>"},{"location":"chapter6/#full-reload","title":"Full Reload","text":"<p>Sometimes, your changes affect the global state, navigation, or require reinitialization. In those cases, Metro falls back to a full reload, restarting the app and resetting all state. This is slower but necessary when deep-level changes occur.</p>"},{"location":"chapter6/#developer-strategy","title":"Developer Strategy","text":"<ul> <li>Use Fast Refresh for styling, component tweaks, and small logic updates.</li> <li>Trigger a full reload when debugging startup issues or global config changes.</li> </ul> <p>Knowing when to expect each behavior prevents unnecessary frustration.</p>"},{"location":"chapter6/#conclusion-seeing-the-invisible","title":"Conclusion: Seeing the Invisible","text":"<p>Babel and Metro are often invisible until they break\u2014but they\u2019re the backbone of React Native development. Babel ensures your modern JavaScript runs on devices, while Metro provides the fast iteration loop developers rely on. By understanding their roles, you\u2019ll interpret error messages with more confidence and know when the problem lies in your code versus the tooling itself.</p> <p>With Part III complete, you now have both survival skills for dependency hell and insights into the build pipeline. In the next part, we\u2019ll step into native builds with Expo Application Services (EAS)\u2014the bridge between development and production-ready mobile apps.</p>"},{"location":"chapter7/","title":"Chapter 7: Introduction to EAS (Expo Application Services)","text":"<p>Up to this point, Expo Go has made development feel light and fast. You scan a QR code, and your app runs instantly. But sooner or later, you\u2019ll hit its limitations: perhaps you want to integrate a payment SDK, test push notifications properly, or prepare an actual App Store build. At that point, Expo Go isn\u2019t enough. You\u2019ll need Expo Application Services (EAS)\u2014Expo\u2019s cloud-based build and deployment platform.</p> <p>This chapter introduces why EAS exists, how to set it up, and how to configure build profiles through <code>eas.json</code>.</p>"},{"location":"chapter7/#why-expo-go-is-not-enough","title":"Why Expo Go Is Not Enough","text":""},{"location":"chapter7/#the-limits-of-expo-go","title":"The Limits of Expo Go","text":"<p>Expo Go is great for early development, but it comes with restrictions:</p> <ul> <li>Only supports libraries included in the Expo SDK.  </li> <li>Cannot add custom native code or certain third-party modules.  </li> <li>Isn\u2019t suitable for creating production-ready binaries (APK/IPA).  </li> </ul> <p>So while Expo Go gets you moving quickly, you\u2019ll eventually need to graduate to custom builds that represent your actual app.</p>"},{"location":"chapter7/#enter-eas","title":"Enter EAS","text":"<p>EAS solves this problem by giving you:</p> <ul> <li>EAS Build \u2013 Cloud-based builds for iOS and Android, without needing Xcode or Android Studio locally.  </li> <li>EAS Submit \u2013 Tools to upload builds directly to the App Store or Play Store.  </li> <li>EAS Update \u2013 Over-the-air (OTA) updates, letting you ship bug fixes instantly without resubmitting to app stores.  </li> </ul> <p>In short, EAS is your bridge from local prototyping to professional, production-ready deployment.</p>"},{"location":"chapter7/#installing-and-configuring-eas-cli","title":"Installing and Configuring EAS CLI","text":""},{"location":"chapter7/#installation","title":"Installation","text":"<p>To start using EAS, install the CLI globally:</p> <pre><code>npm install -g eas-cli\n````\n\nVerify installation:\n\n```bash\neas --version\n</code></pre>"},{"location":"chapter7/#authentication","title":"Authentication","text":"<p>You\u2019ll need an Expo account to use EAS. Log in via the CLI:</p> <pre><code>eas login\n</code></pre> <p>This links your local environment with Expo\u2019s cloud services.</p>"},{"location":"chapter7/#understanding-easjson-build-profiles","title":"Understanding <code>eas.json</code> Build Profiles","text":"<p>At the heart of EAS configuration is the <code>eas.json</code> file in your project root. It defines build profiles\u2014different sets of rules for development, preview, and production builds.</p> <p>Example <code>eas.json</code>:</p> <pre><code>{\n  \"build\": {\n    \"development\": {\n      \"distribution\": \"internal\",\n      \"developmentClient\": true\n    },\n    \"preview\": {\n      \"distribution\": \"internal\"\n    },\n    \"production\": {\n      \"distribution\": \"store\"\n    }\n  }\n}\n</code></pre>"},{"location":"chapter7/#profiles-explained","title":"Profiles Explained","text":"<ul> <li>Development \u2013 For testing with Dev Clients. Includes debugging tools.</li> <li>Preview \u2013 For sharing with testers, but not full production.</li> <li>Production \u2013 Optimized for release; ready to upload to stores.</li> </ul> <p>Each profile can specify options like distribution type, Gradle/Xcode settings, or even custom build scripts.</p>"},{"location":"chapter7/#conclusion-setting-the-stage-for-native-builds","title":"Conclusion: Setting the Stage for Native Builds","text":"<p>EAS is more than just a build tool\u2014it\u2019s the infrastructure that carries your project from sandbox to store. By understanding why Expo Go isn\u2019t enough, installing the CLI, and learning how build profiles work, you\u2019ve taken the first step into serious mobile development.</p> <p>In the next chapter, we\u2019ll put this knowledge into practice by creating your first native build and running it on a device.</p>"},{"location":"chapter8/","title":"Chapter 8: Your First Native Build","text":"<p>After setting up EAS, it\u2019s time to cross the threshold from Expo Go into the world of true native builds. This chapter will guide you through creating your first native build using EAS, installing it on your device, and understanding the differences between dev, preview, and production builds.</p>"},{"location":"chapter8/#running-eas-build-p-android-profile-development","title":"Running <code>eas build -p android --profile development</code>","text":""},{"location":"chapter8/#starting-with-android","title":"Starting with Android","text":"<p>We\u2019ll begin with Android, since generating an APK is often the fastest way to see your app outside Expo Go. From your project root, run:</p> <p>```bash eas build -p android --profile development ````</p> <p>Here\u2019s what this command does:</p> <ul> <li><code>-p android</code> \u2192 Targets Android platform.</li> <li><code>--profile development</code> \u2192 Uses the <code>development</code> profile from <code>eas.json</code>.</li> </ul> <p>EAS will upload your project, run the build in the cloud, and provide a download link once it\u2019s ready.</p>"},{"location":"chapter8/#first-time-prompts","title":"First-Time Prompts","text":"<p>On your first run, EAS may ask you about credentials (keystore for Android, provisioning profiles for iOS). Expo can manage these for you automatically, which is ideal when starting out.</p>"},{"location":"chapter8/#installing-and-testing-the-dev-client-apk","title":"Installing and Testing the Dev Client APK","text":"<p>Once the build is complete, you\u2019ll get a link to download the APK. Install it on your device:</p> <ul> <li>On Android \u2192 Open the link in your browser and install the APK directly.</li> <li>On iOS \u2192 You\u2019ll need to use a simulator or TestFlight (since direct sideloading is restricted).</li> </ul> <p>When you open the Dev Client app, it will look like your project but with one major difference: it can now load custom native modules beyond what Expo Go supports.</p>"},{"location":"chapter8/#testing-workflow","title":"Testing Workflow","text":"<ol> <li>Run your Metro bundler in Dev Client mode:</li> </ol> <p><code>bash    expo start --dev-client</code></p> <ol> <li> <p>Open the Dev Client app.</p> </li> <li> <p>Connect it to Metro using the QR code or deep link.</p> </li> </ol> <p>At this point, your app is running in a build that mirrors production more closely.</p>"},{"location":"chapter8/#differences-between-dev-preview-and-production-builds","title":"Differences Between Dev, Preview, and Production Builds","text":""},{"location":"chapter8/#development-builds","title":"Development Builds","text":"<ul> <li>Includes debugging tools and development menus.</li> <li>Great for local testing with custom native modules.</li> <li>Distributed internally\u2014never to actual users.</li> </ul>"},{"location":"chapter8/#preview-builds","title":"Preview Builds","text":"<ul> <li>Used for testers or staging environments.</li> <li>Distribution is internal, but optimized more like production.</li> <li>Often used before final release.</li> </ul>"},{"location":"chapter8/#production-builds","title":"Production Builds","text":"<ul> <li>Optimized, signed, and ready for app stores.</li> <li>No developer menus or debugging overlays.</li> <li>Must meet store requirements (icons, splash screens, signing keys).</li> </ul> <p>Knowing which profile to use keeps your workflow smooth: dev for building features, preview for testing with colleagues, and production for the real release.</p>"},{"location":"chapter8/#conclusion-the-first-step-into-native-land","title":"Conclusion: The First Step Into Native Land","text":"<p>Running <code>eas build</code> for the first time marks a milestone\u2014you\u2019re no longer limited to Expo Go, but working with real native binaries. Installing and testing your Dev Client gives you confidence that your app will run as expected outside the sandbox.</p> <p>In the next chapter, we\u2019ll connect your Dev Client to Metro more deeply, exploring tunnels, hotspots, and USB fallback methods to keep your feedback loop fast and reliable.</p>"},{"location":"chapter9/","title":"Chapter 9: Connecting Dev Client to Metro","text":"<p>Now that you\u2019ve built and installed a Dev Client, the next step is connecting it to your development server so you can iterate quickly. This is where Metro, Expo\u2019s JavaScript bundler, comes back into play. Unlike Expo Go, which automatically links to Metro behind the scenes, a Dev Client requires a bit more setup. In this chapter, we\u2019ll cover how to start Metro in Dev Client mode, handle different network setups, and use USB fallback when Wi-Fi fails.</p>"},{"location":"chapter9/#running-expo-start-dev-client","title":"Running <code>expo start --dev-client</code>","text":""},{"location":"chapter9/#why-a-special-command","title":"Why a Special Command?","text":"<p>When using Expo Go, the app already knows how to connect to Metro. But with a Dev Client, you\u2019re running a custom binary\u2014so Metro must be started in a mode tailored for it.</p> <p>From your project root, run:</p> <p>```bash expo start --dev-client ````</p> <p>This command launches Metro with the right configuration so your Dev Client app can connect. A QR code will appear in the terminal (or in the browser UI), which you can scan with your device.</p>"},{"location":"chapter9/#the-experience","title":"The Experience","text":"<p>Once connected, changes to your code are streamed directly to your Dev Client app. Fast Refresh works just like before\u2014but now you can test native modules not available in Expo Go.</p>"},{"location":"chapter9/#using-tunnels-hotspots-and-deep-links","title":"Using Tunnels, Hotspots, and Deep Links","text":""},{"location":"chapter9/#the-network-challenge","title":"The Network Challenge","text":"<p>Your phone and laptop must be on the same network for Metro to communicate. This isn\u2019t always straightforward\u2014especially with corporate firewalls, hotel Wi-Fi, or spotty connections.</p> <p>Expo provides multiple solutions:</p> <ul> <li>LAN (Local Network) \u2013 Fastest and most stable when both devices share the same Wi-Fi.</li> <li>Tunnel \u2013 Creates a secure tunnel through Expo\u2019s servers, allowing connection even when LAN fails. Slower but more reliable in restrictive networks.</li> <li>Hotspot \u2013 Share your laptop\u2019s or phone\u2019s hotspot to force both devices onto the same connection.</li> </ul>"},{"location":"chapter9/#deep-linking","title":"Deep Linking","text":"<p>Sometimes scanning a QR code doesn\u2019t work. In that case, Expo provides a deep link URL (e.g., <code>exp://192.168.x.x:8081</code>) you can open directly on your device. This bypasses QR scanning issues and connects your Dev Client directly.</p>"},{"location":"chapter9/#usb-fallback-with-adb-reverse","title":"USB Fallback with <code>adb reverse</code>","text":"<p>When all else fails on Android, there\u2019s still one trusty option: USB debugging with <code>adb</code>.</p> <ol> <li> <p>Connect your Android device via USB.</p> </li> <li> <p>Run:</p> </li> </ol> <p><code>bash    adb reverse tcp:8081 tcp:8081</code></p> <ol> <li>Start Metro with:</li> </ol> <p><code>bash    expo start --dev-client</code></p> <p>This forwards Metro\u2019s traffic over USB, ensuring a stable connection even when Wi-Fi isn\u2019t cooperating. (For iOS, USB debugging is trickier and usually requires Xcode.)</p>"},{"location":"chapter9/#conclusion-reliable-iteration","title":"Conclusion: Reliable Iteration","text":"<p>By now, you\u2019ve learned how to connect your Dev Client to Metro across different scenarios: standard LAN, fallback tunnels, personal hotspots, and even USB with <code>adb reverse</code>. Mastering these options ensures you can always iterate on your app, regardless of network conditions.</p> <p>With Part IV complete, you now know how to move beyond Expo Go, create native builds with EAS, and connect them back to Metro for development. In the next part, we\u2019ll step away from tooling and explore practical lessons and next steps\u2014battle-tested advice for keeping your projects healthy and preparing for real-world deployment.</p>"}]}